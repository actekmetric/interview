name: Observability Stack CD

on:
  push:
    branches:
      - main
      - master
    paths:
      - 'sre/helm/observability/**'
      - 'sre/terraform/modules/amp/**'
      - 'sre/terraform/modules/grafana/**'
      - '.github/workflows/sre-observability-cd.yml'

  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        type: choice
        options:
          - dev
          - qa
          - prod
        default: dev
      action:
        description: 'Action to perform'
        required: true
        type: choice
        options:
          - deploy
          - upgrade
          - uninstall
        default: deploy

# Prevent concurrent deployments to the same environment
concurrency:
  group: observability-cd-${{ github.event.inputs.environment || 'auto' }}
  cancel-in-progress: false

# Required for OIDC authentication with AWS
permissions:
  id-token: write   # Required for AWS OIDC authentication
  contents: read    # Required to checkout repository

jobs:
  # Determine which environments to deploy to
  determine-environments:
    name: Determine Deployment Targets
    runs-on: ubuntu-latest
    outputs:
      environments: ${{ steps.determine.outputs.environments }}
    steps:
      - name: Determine environments
        id: determine
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            # Manual: deploy only to specified environment
            echo "environments=[\"${{ inputs.environment }}\"]" >> $GITHUB_OUTPUT
          else
            # Automatic: deploy to dev only (safety)
            echo "environments=[\"dev\"]" >> $GITHUB_OUTPUT
          fi

  # Publish Helm Chart to S3
  publish-chart:
    name: Publish Observability Chart to S3
    runs-on: ubuntu-latest
    needs: determine-environments
    if: github.event.inputs.action != 'uninstall'
    outputs:
      chart-version: ${{ steps.get-version.outputs.version }}
      chart-name: ${{ steps.get-version.outputs.name }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install Helm
        uses: azure/setup-helm@v3
        with:
          version: v3.14.0

      - name: Lint Helm Chart
        run: |
          echo "ðŸ” Linting Helm chart..."
          helm lint sre/helm/observability/
          echo "âœ… Helm chart linting passed"

      - name: Get Chart Info
        id: get-version
        run: |
          CHART_NAME=$(helm show chart sre/helm/observability | grep '^name:' | awk '{print $2}')
          CHART_VERSION=$(helm show chart sre/helm/observability | grep '^version:' | awk '{print $2}')
          APP_VERSION=$(helm show chart sre/helm/observability | grep '^appVersion:' | awk '{print $2}' | tr -d '"')

          echo "name=${CHART_NAME}" >> $GITHUB_OUTPUT
          echo "version=${CHART_VERSION}" >> $GITHUB_OUTPUT
          echo "app-version=${APP_VERSION}" >> $GITHUB_OUTPUT

          echo "ðŸ“¦ Chart: ${CHART_NAME}"
          echo "ðŸ·ï¸  Version: ${CHART_VERSION}"
          echo "ðŸ³ App Version: ${APP_VERSION}"

      - name: Validate Chart Template
        run: |
          echo "ðŸ” Validating Helm chart templates..."
          helm template test-release sre/helm/observability --dry-run > /dev/null
          echo "âœ… Helm chart templates are valid"

      - name: Configure AWS credentials
        uses: ./.github/actions/aws-assume-role
        with:
          environment: dev
          role-arn: ${{ secrets.AWS_DEV_ROLE_ARN }}
          account-id: ${{ secrets.AWS_DEV_ACCOUNT_ID }}
          aws-region: us-east-1

      - name: Install helm-s3 plugin
        run: |
          echo "ðŸ“¦ Installing helm-s3 plugin..."
          helm plugin install https://github.com/hypnoglow/helm-s3.git --version 0.16.0
          helm plugin list

      - name: Initialize S3 Helm repository
        run: |
          BUCKET_NAME="tekmetric-helm-charts-dev"
          REPO_PATH="s3://${BUCKET_NAME}/charts"

          echo "ðŸ”§ Initializing S3 Helm repository..."
          helm s3 init --ignore-if-exists ${REPO_PATH}
          echo "âœ… Repository ready"

      - name: Package and Push Chart to S3
        run: |
          BUCKET_NAME="tekmetric-helm-charts-dev"
          REPO_PATH="s3://${BUCKET_NAME}/charts"
          REPO_NAME="tekmetric-s3"
          CHART_NAME="${{ steps.get-version.outputs.name }}"
          CHART_VERSION="${{ steps.get-version.outputs.version }}"

          echo "ðŸ“¦ Packaging Helm chart..."
          helm package sre/helm/observability \
            --version ${CHART_VERSION} \
            --app-version ${{ steps.get-version.outputs.app-version }}

          echo "ðŸ“¤ Adding S3 repo..."
          helm repo add ${REPO_NAME} ${REPO_PATH}

          echo "ðŸ“¤ Pushing chart to S3..."
          CHART_FILE="${CHART_NAME}-${CHART_VERSION}.tgz"
          helm s3 push ${CHART_FILE} ${REPO_NAME} --force

          echo "âœ… Chart pushed to ${REPO_PATH}"

          # Verify
          echo "ðŸ” Verifying chart availability..."
          helm repo update ${REPO_NAME}
          helm search repo ${REPO_NAME}/${CHART_NAME} --versions | head -5

      - name: Summary
        run: |
          echo "## ðŸ“¦ Observability Helm Chart Published to S3" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Chart Name:** \`${{ steps.get-version.outputs.name }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Chart Version:** \`${{ steps.get-version.outputs.version }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Repository:** \`s3://tekmetric-helm-charts-dev/charts\`" >> $GITHUB_STEP_SUMMARY

  # Deploy to DEV
  deploy-dev:
    name: Deploy to DEV
    runs-on: ubuntu-latest
    needs: [determine-environments, publish-chart]
    if: |
      always() &&
      (needs.publish-chart.result == 'success' || needs.publish-chart.result == 'skipped') &&
      contains(fromJson(needs.determine-environments.outputs.environments), 'dev')
    environment:
      name: dev
      url: https://g-dev-grafana.grafana-workspace.us-east-1.amazonaws.com
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform and Terragrunt
        uses: ./.github/actions/terraform-setup

      - name: Assume AWS Role
        uses: ./.github/actions/aws-assume-role
        with:
          environment: dev
          role-arn: ${{ secrets.AWS_DEV_ROLE_ARN }}
          account-id: ${{ secrets.AWS_DEV_ACCOUNT_ID }}

      - name: Get Terraform Outputs
        id: terraform-outputs
        run: |
          cd sre/terragrunt/environments/dev/observability/amp

          # Get AMP workspace endpoint
          AMP_ENDPOINT=$(terragrunt output -raw workspace_endpoint 2>/dev/null || echo "")
          if [[ -z "$AMP_ENDPOINT" ]]; then
            echo "::error::Failed to get AMP workspace endpoint. Ensure AMP is deployed."
            exit 1
          fi

          # Get Prometheus Agent IAM role ARN
          ROLE_ARN=$(terragrunt output -raw prometheus_agent_role_arn 2>/dev/null || echo "")
          if [[ -z "$ROLE_ARN" ]]; then
            echo "::error::Failed to get Prometheus Agent IAM role ARN. Ensure AMP is deployed."
            exit 1
          fi

          echo "amp-endpoint=${AMP_ENDPOINT}" >> $GITHUB_OUTPUT
          echo "role-arn=${ROLE_ARN}" >> $GITHUB_OUTPUT

          echo "ðŸ“Š AMP Endpoint: ${AMP_ENDPOINT}"
          echo "ðŸ” IAM Role ARN: ${ROLE_ARN}"

      - name: Configure kubectl
        run: |
          aws eks update-kubeconfig \
            --name tekmetric-dev \
            --region us-east-1

      - name: Install helm-s3 plugin
        run: |
          echo "ðŸ“¦ Installing helm-s3 plugin..."
          helm plugin install https://github.com/hypnoglow/helm-s3.git --version 0.16.0
          helm plugin list

      - name: Add S3 Helm Repository
        run: |
          BUCKET_NAME="tekmetric-helm-charts-dev"
          REPO_PATH="s3://${BUCKET_NAME}/charts"
          REPO_NAME="tekmetric-s3"

          echo "ðŸ“¤ Adding S3 repo..."
          helm repo add ${REPO_NAME} ${REPO_PATH}
          helm repo update ${REPO_NAME}

          echo "âœ… Repository added and updated"

      - name: Ensure Namespace Exists with Helm Labels
        if: github.event.inputs.action != 'uninstall'
        run: |
          # Create namespace if it doesn't exist, or add Helm labels if it does
          kubectl create namespace observability --dry-run=client -o yaml | kubectl apply -f -

          # Add Helm ownership labels and annotations so Helm can manage it
          kubectl label namespace observability app.kubernetes.io/managed-by=Helm --overwrite
          kubectl annotate namespace observability meta.helm.sh/release-name=observability --overwrite
          kubectl annotate namespace observability meta.helm.sh/release-namespace=observability --overwrite

          echo "âœ… Namespace 'observability' is ready with Helm labels"

      - name: Deploy/Upgrade Observability Stack
        if: github.event.inputs.action != 'uninstall'
        run: |
          REPO_NAME="tekmetric-s3"
          CHART_NAME="${{ needs.publish-chart.outputs.chart-name }}"
          CHART_VERSION="${{ needs.publish-chart.outputs.chart-version }}"

          echo "ðŸ“¦ Deploying ${CHART_NAME}:${CHART_VERSION} from S3..."

          helm upgrade --install observability ${REPO_NAME}/${CHART_NAME} \
            --version ${CHART_VERSION} \
            --namespace observability \
            --values sre/helm/observability/values-dev.yaml \
            --set prometheusAgent.serviceAccount.annotations."eks\.amazonaws\.com/role-arn"="${{ steps.terraform-outputs.outputs.role-arn }}" \
            --set prometheusAgent.amp.remoteWriteUrl="${{ steps.terraform-outputs.outputs.amp-endpoint }}" \
            --wait \
            --timeout 10m

          echo "âœ… Helm deployment completed"

      - name: Uninstall Observability Stack
        if: github.event.inputs.action == 'uninstall'
        run: |
          helm uninstall observability --namespace observability --wait || true
          echo "ðŸ—‘ï¸ Observability stack uninstalled"

      - name: Verify Deployment
        if: github.event.inputs.action != 'uninstall'
        run: |
          echo "ðŸ“‹ Checking pod status..."
          kubectl get pods -n observability

          echo ""
          echo "â³ Waiting for pods to be ready..."
          kubectl wait --for=condition=ready pod \
            --all \
            --namespace observability \
            --timeout=300s

          echo ""
          echo "âœ… All pods are ready!"

          echo ""
          echo "ðŸ“Š Checking Prometheus Agent logs..."
          kubectl logs -n observability deployment/prometheus-agent --tail=20 || true

      - name: Generate Deployment Summary
        if: always() && github.event.inputs.action != 'uninstall'
        run: |
          cat >> $GITHUB_STEP_SUMMARY << 'EOF'
          ## ðŸ“Š Observability Stack Deployment - DEV

          **Environment:** dev
          **Action:** ${{ github.event.inputs.action || 'deploy' }}
          **Status:** ${{ job.status }}

          ### Components Deployed
          - âœ… Prometheus Agent (scrapes metrics, sends to AMP)
          - âœ… kube-state-metrics (cluster metrics)
          - âœ… node-exporter (node metrics)

          ### Configuration
          - **AMP Endpoint:** `${{ steps.terraform-outputs.outputs.amp-endpoint }}`
          - **IRSA Role:** `${{ steps.terraform-outputs.outputs.role-arn }}`
          - **Namespace:** `observability`

          ### Quick Commands
          ```bash
          # View pods
          kubectl get pods -n observability

          # View Prometheus Agent logs
          kubectl logs -n observability deployment/prometheus-agent -f

          # Port-forward to Prometheus
          kubectl port-forward -n observability deployment/prometheus-agent 9090:9090

          # Check metrics in Grafana
          # Login to AMG and query: up{job="kubernetes-pods"}
          ```
          EOF

  # Deploy to QA
  deploy-qa:
    name: Deploy to QA
    runs-on: ubuntu-latest
    needs: determine-environments
    if: contains(fromJson(needs.determine-environments.outputs.environments), 'qa')
    environment:
      name: qa
      url: https://g-qa-grafana.grafana-workspace.us-east-1.amazonaws.com
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform and Terragrunt
        uses: ./.github/actions/terraform-setup

      - name: Assume AWS Role
        uses: ./.github/actions/aws-assume-role
        with:
          environment: qa
          role-arn: ${{ secrets.AWS_QA_ROLE_ARN }}
          account-id: ${{ secrets.AWS_QA_ACCOUNT_ID }}

      - name: Get Terraform Outputs
        id: terraform-outputs
        run: |
          cd sre/terragrunt/environments/qa/observability/amp

          AMP_ENDPOINT=$(terragrunt output -raw workspace_endpoint 2>/dev/null || echo "")
          if [[ -z "$AMP_ENDPOINT" ]]; then
            echo "::error::Failed to get AMP workspace endpoint. Ensure AMP is deployed."
            exit 1
          fi

          ROLE_ARN=$(terragrunt output -raw prometheus_agent_role_arn 2>/dev/null || echo "")
          if [[ -z "$ROLE_ARN" ]]; then
            echo "::error::Failed to get Prometheus Agent IAM role ARN. Ensure AMP is deployed."
            exit 1
          fi

          echo "amp-endpoint=${AMP_ENDPOINT}" >> $GITHUB_OUTPUT
          echo "role-arn=${ROLE_ARN}" >> $GITHUB_OUTPUT

      - name: Configure kubectl
        run: |
          aws eks update-kubeconfig \
            --name tekmetric-qa \
            --region us-east-1

      - name: Prepare Helm Values
        run: |
          cd sre/helm/observability

          cat > values-qa-generated.yaml << EOF
          global:
            environment: qa
            region: us-east-1

          prometheusAgent:
            enabled: true
            replicas: 1

            serviceAccount:
              create: true
              name: prometheus-agent
              annotations:
                eks.amazonaws.com/role-arn: "${{ steps.terraform-outputs.outputs.role-arn }}"

            amp:
              remoteWriteUrl: "${{ steps.terraform-outputs.outputs.amp-endpoint }}"
              sigv4:
                enabled: true
                region: us-east-1

            scrapeInterval: 30s
            scrapeTimeout: 10s

            resources:
              requests:
                memory: "512Mi"
                cpu: "250m"
              limits:
                memory: "1Gi"
                cpu: "500m"

          kubeStateMetrics:
            enabled: true
            resources:
              requests:
                memory: "128Mi"
                cpu: "100m"
              limits:
                memory: "256Mi"
                cpu: "200m"

          nodeExporter:
            enabled: true
            resources:
              requests:
                memory: "64Mi"
                cpu: "50m"
              limits:
                memory: "128Mi"
                cpu: "100m"
          EOF

      - name: Ensure Namespace Exists with Helm Labels
        if: github.event.inputs.action != 'uninstall'
        run: |
          # Create namespace if it doesn't exist, or add Helm labels if it does
          kubectl create namespace observability --dry-run=client -o yaml | kubectl apply -f -

          # Add Helm ownership labels and annotations so Helm can manage it
          kubectl label namespace observability app.kubernetes.io/managed-by=Helm --overwrite
          kubectl annotate namespace observability meta.helm.sh/release-name=observability --overwrite
          kubectl annotate namespace observability meta.helm.sh/release-namespace=observability --overwrite

          echo "âœ… Namespace 'observability' is ready with Helm labels"

      - name: Deploy/Upgrade Observability Stack
        if: github.event.inputs.action != 'uninstall'
        run: |
          cd sre/helm/observability

          helm upgrade --install observability . \
            --namespace observability \
            --values values-qa-generated.yaml \
            --wait \
            --timeout 10m

      - name: Uninstall Observability Stack
        if: github.event.inputs.action == 'uninstall'
        run: |
          helm uninstall observability --namespace observability --wait || true

      - name: Verify Deployment
        if: github.event.inputs.action != 'uninstall'
        run: |
          kubectl get pods -n observability
          kubectl wait --for=condition=ready pod \
            --all \
            --namespace observability \
            --timeout=300s

  # Deploy to PROD
  deploy-prod:
    name: Deploy to PROD
    runs-on: ubuntu-latest
    needs: determine-environments
    if: contains(fromJson(needs.determine-environments.outputs.environments), 'prod')
    environment:
      name: prod
      url: https://g-prod-grafana.grafana-workspace.us-east-1.amazonaws.com
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform and Terragrunt
        uses: ./.github/actions/terraform-setup

      - name: Assume AWS Role
        uses: ./.github/actions/aws-assume-role
        with:
          environment: prod
          role-arn: ${{ secrets.AWS_PROD_ROLE_ARN }}
          account-id: ${{ secrets.AWS_PROD_ACCOUNT_ID }}

      - name: Get Terraform Outputs
        id: terraform-outputs
        run: |
          cd sre/terragrunt/environments/prod/observability/amp

          AMP_ENDPOINT=$(terragrunt output -raw workspace_endpoint 2>/dev/null || echo "")
          if [[ -z "$AMP_ENDPOINT" ]]; then
            echo "::error::Failed to get AMP workspace endpoint. Ensure AMP is deployed."
            exit 1
          fi

          ROLE_ARN=$(terragrunt output -raw prometheus_agent_role_arn 2>/dev/null || echo "")
          if [[ -z "$ROLE_ARN" ]]; then
            echo "::error::Failed to get Prometheus Agent IAM role ARN. Ensure AMP is deployed."
            exit 1
          fi

          echo "amp-endpoint=${AMP_ENDPOINT}" >> $GITHUB_OUTPUT
          echo "role-arn=${ROLE_ARN}" >> $GITHUB_OUTPUT

      - name: Configure kubectl
        run: |
          aws eks update-kubeconfig \
            --name tekmetric-prod \
            --region us-east-1

      - name: Prepare Helm Values
        run: |
          cd sre/helm/observability

          cat > values-prod-generated.yaml << EOF
          global:
            environment: prod
            region: us-east-1

          prometheusAgent:
            enabled: true
            replicas: 2  # HA for production

            serviceAccount:
              create: true
              name: prometheus-agent
              annotations:
                eks.amazonaws.com/role-arn: "${{ steps.terraform-outputs.outputs.role-arn }}"

            amp:
              remoteWriteUrl: "${{ steps.terraform-outputs.outputs.amp-endpoint }}"
              sigv4:
                enabled: true
                region: us-east-1

            scrapeInterval: 15s  # More frequent for prod
            scrapeTimeout: 10s

            resources:
              requests:
                memory: "1Gi"
                cpu: "500m"
              limits:
                memory: "2Gi"
                cpu: "1000m"

          kubeStateMetrics:
            enabled: true
            resources:
              requests:
                memory: "256Mi"
                cpu: "200m"
              limits:
                memory: "512Mi"
                cpu: "400m"

          nodeExporter:
            enabled: true
            resources:
              requests:
                memory: "128Mi"
                cpu: "100m"
              limits:
                memory: "256Mi"
                cpu: "200m"
          EOF

      - name: Ensure Namespace Exists with Helm Labels
        if: github.event.inputs.action != 'uninstall'
        run: |
          # Create namespace if it doesn't exist, or add Helm labels if it does
          kubectl create namespace observability --dry-run=client -o yaml | kubectl apply -f -

          # Add Helm ownership labels and annotations so Helm can manage it
          kubectl label namespace observability app.kubernetes.io/managed-by=Helm --overwrite
          kubectl annotate namespace observability meta.helm.sh/release-name=observability --overwrite
          kubectl annotate namespace observability meta.helm.sh/release-namespace=observability --overwrite

          echo "âœ… Namespace 'observability' is ready with Helm labels"

      - name: Deploy/Upgrade Observability Stack
        if: github.event.inputs.action != 'uninstall'
        run: |
          cd sre/helm/observability

          helm upgrade --install observability . \
            --namespace observability \
            --values values-prod-generated.yaml \
            --wait \
            --timeout 10m

      - name: Uninstall Observability Stack
        if: github.event.inputs.action == 'uninstall'
        run: |
          helm uninstall observability --namespace observability --wait || true

      - name: Verify Deployment
        if: github.event.inputs.action != 'uninstall'
        run: |
          kubectl get pods -n observability
          kubectl wait --for=condition=ready pod \
            --all \
            --namespace observability \
            --timeout=300s
